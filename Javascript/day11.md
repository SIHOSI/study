# **배열**

- 배열은 값의 순서 있는 집합.
- 값을 요소라 부르며, 위치를 나타내는 숫자인 인덱스가 있다.
- 배열에는 타입이 없고, 배열 하나에 여러 타입이 섞여 있어도 상관 무.
- js 배열은 0으로 시작하는 32비트 인덱스를 사용한다. 요소의 수는 최대 4,294,967,295개
- 배열은 동적이다.
- 성긴(sparse) 배열을 허용한다. 즉, 요소의 인덱스가 꼭 이어질 필요가 없고 그 사이에 갭이 있어도 된다.
- 배열은 모두 length 프로퍼티가 있다.
- js 배열은 객체의 특별한 형태.
- 숫자로 된 인덱스된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근 가능.
- 배열은 Array.prototype에서 프로퍼티를 상속.
- 이 프로퍼티에 배열 조작 메서드가 많이 포함.
- 이 메소드는 배열 비슷한 객체에서도 동작.
- 문자열은 문자로 구성된 배열처럼 동작.
- ES6에서 형식화 배열(typed array) 라 부르는 새로운 배열 클래스를 도입. 길이가 고정적이며 요소 타입도 숫자로 고정되어 있다. 빠르고 이진 데이터에 바이트 수준에서 접근 가능.
  
</br>
</br>


## 1. 배열 생성
- 배열을 만드는 방법
  - 배열 리터럴
  - 이터러블 객체에 분해 연산자 ... 적용
  - Array() 생성자
  - Array.of()와 Array.from() 팩토리 메서드
  
</br>

### 배열 리터럴
- 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태.
```javascript
let misc = [1.1, true, "a"]
```
- 임의의 표현식을 써도 된다.
- 배열 리터럴 안에 객체 리터럴이나 다른 배열 리터럴을 써도 된다.

</br>

- 배열 리터럴 콤마 사이에 값이 없으면 성긴 배열이 생성.
- 값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만 검색하면 undefined가 반환.

```javascript
let undefs = [,,] // 요소가 없지만 길이가 2인 배열
```
- 배열 리터럴 문법은 마지막에 콤마를 허용, [,,]의 길이는 3이 아니라 2이다.

</br>

### 분해 연산자
```javascript
let b = [0, ...a, 4] // a = [1,2,3] , b== 0,1,2,3,4
```
- 분해 연산자는 배열을 얕게 복사할 때도 유용하다.
```javascript
let original = [1,2,3]
let copy = [...original]
copy[0] = 0 // 사본을 수정해도 원본에는 영향이 없다.
original[0] // 1
```

- 분해 연산자는 모든 이터러블 객체에 동작.
- 이터러블 객체는 for/of 루프의 대상이 될 수 있는 객체.
- 문자열 역시 이터러블
- 세트 또한 이터러블
- 배열에서 중복된 요소를 제거하고 싶을 때는 먼저 배열을 세트로 변환한 다음, 분해 연산자를 써서 배열로 되돌릴 수 있다.
```javascript
let letters = [...'hello'] // 'h', 'e', 'l', 'l', 'o'
[...new Set(letters)] // ['h', 'e', 'l', 'o']
```

</br>

### Array() 생성자
- 인자 없이 호출
```javascript
let a = new Array() // 요소 없는 빈 배열을 생성, [] 와 동등
```
- 배열 길이를 나타내는 숫자 인자 하나로 호출
```javascript
let a = new Array(10) // 지정된 길이를 가진 배열 생성.
```
- 배열 요소를 두 개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
```javascript
let a = new Array(5,4,3,2,1,"test") // 생성자의 인자가 새 배열의 인자가 된다.
```

</br>

### Array.of()
- Array() 생성자는 숫자 인자가 하나면 길이로, 숫자 인자가 두 개 이상 있으면 이들을 각각 요소로 취급.
- 따라서, Array() 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.
- ES6의 Array.of() 함수가 이 문제를 해결.
- 인자의 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용.

</br>

```javascript
Array.of() // []
Array.of(10) // [10]
Array.of(1,2,3) // [1,2,3]
```

### Array.from()
- 첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환.
- Array.from(iterable) 은 [...iterable] 과 동등하다.

```javascript
let copy = Array.from(original) // 배열을 쉽게 복사할 수 있다.
```

- **배열 비슷한 객체를 진정한 배열로 바꾸는 방법**.
- 배열 비슷한 객체란 숫자인 length 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체를 말한다.
- 선택사항으로 두 번째 인자를 받는다.
- 두 번째 인자로 함수를 전달하면, 새 배열을 생성할 때 소스 객체의 각 요소를 이 함수에 전달하고 반환값을 배열에 저장.

</br>

## 성긴 배열
- 인덱스가 연속적이지 않은 배열
- 일반적으로 배열의 length 프로퍼티는 배열에 포함된 요소의 개수.
- 성긴 배열의 경우 length 프로퍼티의 값이 요소의 개수 보다 크다.
- Array() 생성자를 사용하거나, 현재 배열 length 보다 큰 인덱스에 요소를 할당하면 만들어진다.

```javascript
let a = new Array(5) // 요소가 없지만 a.length는 5
a = [] // 요소가 없고 length가 0
a[1000] = 0 // 요소 하나를 추가하지만 길이는 1001
```

- delete 연산자를 사용해 성긴 배열을 만들 수 있다.
- 일반적인 배열에 비해 조금 느리지만 메모리를 효율적으로 사용.
- 요소를 검색하는 시간은 일반 적인 객체 프로퍼티 검색과 비슷.
- [1,,3] 처럼 리터럴에 콤바를 반복하면 성긴 배열이 만들어진다.

```javascript
let a1 = [,] // 요소가 없고 길이는 1
let a2 = [undefined] // undefined 요소가 하나 존재.
0 in a1 // false 인덱스 0 에 요소가 없음
0 in a2 // true 인덱스 0에 요소 undefined 존재.
```

</br>

## 배열 길이
- 모든 배열에는 length 프로퍼티 존재
- 이 프로퍼티는 일반적인 객체와 배열을 구분하는 특징.
- 일반적인 배열에서 length 프로퍼티는 인덱스에 1을 더한 값
- 성긴 배열의 length 프로퍼티는 포함된 요소 개수보다 크다.
- length 보다 크거나 같은 인덱스는 존재하지 않는다.
- 이를 위해 js 배열에는 특별한 동작 두가지가 있다.
  - 배열의 현재 길이 이상인 i 인덱스에 값을 할당하면 length 프로퍼티를 i + 1 로 갱신
  - length 프로퍼티를 현재 값보다 작은 n 으로 지정하면 n 이상인 배열 요소는 모두 삭제.

```javascript
a = [1,2,3,4,5]
a.length = 3 // a는 [1,2,3]
a.length = 0 // 요소 전체를 삭제 [] 와 동등
a.length = 5 // 길이는 5 요소는 없음
```

</br>

## 배열 요소 추가와 삭제
- 가장 단순한 방법은 새 인덱스에 값을 할당하는 방법.
- push() 메서드는 배열 마지막에 값을 추가.
```javascript
let a = []
a.push('zero')
a.push('one','two') // a = 'zero', 'one', 'two'
```
- push()는 a[a.length] 에 값을 할당하는 것과 같다.
- unshift() 를 사용해 배열의 맨 앞에 값을 삽입하고 기존의 요소를 뒤로 미는 것도 가능.
- pop() 메서드는 push()의 반대로 배열의 마지막 요소를 제거하고 그 값을 반환하며 배열의 길이를 1 줄인다.
- shift() 메서드는 배열의 첫 번째 요소를 제거해 반환하며 길이를 1 중리고 나머지 요소를 모두 앞으로 당긴다.

</br>

- delete 연산자로 배열 요소를 삭제 할 수 있다.
```javascript
let a = [1,2,3]
delete a[2] // 1,2
2 in a // false
a.length // 3 delete는 길이에 영향을 주지 않는다.
```

- 배열 요소를 삭제하는 것은 그 요소에 undefined를 할당하는 것과 비슷하다. 완전 같지는 않다.
- length프로퍼티가 변하지 않고 빈 공간을 메우기 위해 요소가 이동하지도 않는다.

</br>

- 배열 요소를 삽입, 삭제, 대체하는 범용 메서드 splice() 가 있다.
- length 프로퍼티를 변경하고 필요에 따라 요소를 앞뒤로 움직인다.


</br>

## 배열 순회
- 가장 쉬운 방법은 for/of
```javascript
let letters = [...'hello']
let string = ''
for(let letter of letters)
    string += letter
console.log(string) // hello
```
- 오름차순으로 요소를 반환
- 성긴 배열도 마찬가지로 존재하지 않는 배열 요소에 대해서는 undefined를 반환.
- 각 요소의 인덱스가 필요하다면 entries()메서드와 분해 할당을 이용.
  
```javascript
let everyother = ''
for(let [index, letter] of letters.entries()) {
    if (index % 2 == 0)
        everyother += letter
}
everyother // hlo
```

</br>

- forEach()도 배열을 순회하는 좋은 방법
- for루프의 변형이 아니라 배열 순회를 함수형으로 바꾼 배열 메서드.
- forEach()는 전달 받은 함수를 각 배열 요소에서 호출.

```javascript
let uppercase = ''
letters.forEach(letter => {
    uppercase += letter.toUpperCase()
})
uppercase // HELLO
```

- 배열을 순서대로 순회하며 배열 인덱스를 함수의 두 번째 인자로 전달.
- for/of와 달리 forEach()는 성긴 배열을 인식, 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.

```javascript
let a = [1,2,3]
delete a[1]
a.forEach(n => console.log(n)) // 1 3
let b = [1,2,3]
b[1] = undefined
b.forEach(n => console.log(n)) // 1 undefined 3 // 삭제는 undefined 할당과 비슷한거지 같지 않다.
```

