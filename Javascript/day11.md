# **배열**

- 배열은 값의 순서 있는 집합.
- 값을 요소라 부르며, 위치를 나타내는 숫자인 인덱스가 있다.
- 배열에는 타입이 없고, 배열 하나에 여러 타입이 섞여 있어도 상관 무.
- js 배열은 0으로 시작하는 32비트 인덱스를 사용한다. 요소의 수는 최대 4,294,967,295개
- 배열은 동적이다.
- 성긴(sparse) 배열을 허용한다. 즉, 요소의 인덱스가 꼭 이어질 필요가 없고 그 사이에 갭이 있어도 된다.
- 배열은 모두 length 프로퍼티가 있다.
- js 배열은 객체의 특별한 형태.
- 숫자로 된 인덱스된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근 가능.
- 배열은 Array.prototype에서 프로퍼티를 상속.
- 이 프로퍼티에 배열 조작 메서드가 많이 포함.
- 이 메소드는 배열 비슷한 객체에서도 동작.
- 문자열은 문자로 구성된 배열처럼 동작.
- ES6에서 형식화 배열(typed array) 라 부르는 새로운 배열 클래스를 도입. 길이가 고정적이며 요소 타입도 숫자로 고정되어 있다. 빠르고 이진 데이터에 바이트 수준에서 접근 가능.

</br>
</br>

## 1. 배열 생성

- 배열을 만드는 방법
  - 배열 리터럴
  - 이터러블 객체에 분해 연산자 ... 적용
  - Array() 생성자
  - Array.of()와 Array.from() 팩토리 메서드

</br>

### 배열 리터럴

- 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태.

```javascript
let misc = [1.1, true, 'a'];
```

- 임의의 표현식을 써도 된다.
- 배열 리터럴 안에 객체 리터럴이나 다른 배열 리터럴을 써도 된다.

</br>

- 배열 리터럴 콤마 사이에 값이 없으면 성긴 배열이 생성.
- 값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만 검색하면 undefined가 반환.

```javascript
let undefs = [, ,]; // 요소가 없지만 길이가 2인 배열
```

- 배열 리터럴 문법은 마지막에 콤마를 허용, [,,]의 길이는 3이 아니라 2이다.

</br>

### 분해 연산자

```javascript
let b = [0, ...a, 4]; // a = [1,2,3] , b== 0,1,2,3,4
```

- 분해 연산자는 배열을 얕게 복사할 때도 유용하다.

```javascript
let original = [1, 2, 3];
let copy = [...original];
copy[0] = 0; // 사본을 수정해도 원본에는 영향이 없다.
original[0]; // 1
```

- 분해 연산자는 모든 이터러블 객체에 동작.
- 이터러블 객체는 for/of 루프의 대상이 될 수 있는 객체.
- 문자열 역시 이터러블
- 세트 또한 이터러블
- 배열에서 중복된 요소를 제거하고 싶을 때는 먼저 배열을 세트로 변환한 다음, 분해 연산자를 써서 배열로 되돌릴 수 있다.

```javascript
let letters = [...'hello'] // 'h', 'e', 'l', 'l', 'o'
[...new Set(letters)] // ['h', 'e', 'l', 'o']
```

</br>

### Array() 생성자

- 인자 없이 호출

```javascript
let a = new Array(); // 요소 없는 빈 배열을 생성, [] 와 동등
```

- 배열 길이를 나타내는 숫자 인자 하나로 호출

```javascript
let a = new Array(10); // 지정된 길이를 가진 배열 생성.
```

- 배열 요소를 두 개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출

```javascript
let a = new Array(5, 4, 3, 2, 1, 'test'); // 생성자의 인자가 새 배열의 인자가 된다.
```

</br>

### Array.of()

- Array() 생성자는 숫자 인자가 하나면 길이로, 숫자 인자가 두 개 이상 있으면 이들을 각각 요소로 취급.
- 따라서, Array() 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.
- ES6의 Array.of() 함수가 이 문제를 해결.
- 인자의 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용.

</br>

```javascript
Array.of(); // []
Array.of(10); // [10]
Array.of(1, 2, 3); // [1,2,3]
```

### Array.from()

- 첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환.
- Array.from(iterable) 은 [...iterable] 과 동등하다.

```javascript
let copy = Array.from(original); // 배열을 쉽게 복사할 수 있다.
```

- **배열 비슷한 객체를 진정한 배열로 바꾸는 방법**.
- 배열 비슷한 객체란 숫자인 length 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체를 말한다.
- 선택사항으로 두 번째 인자를 받는다.
- 두 번째 인자로 함수를 전달하면, 새 배열을 생성할 때 소스 객체의 각 요소를 이 함수에 전달하고 반환값을 배열에 저장.

</br>

## 성긴 배열

- 인덱스가 연속적이지 않은 배열
- 일반적으로 배열의 length 프로퍼티는 배열에 포함된 요소의 개수.
- 성긴 배열의 경우 length 프로퍼티의 값이 요소의 개수 보다 크다.
- Array() 생성자를 사용하거나, 현재 배열 length 보다 큰 인덱스에 요소를 할당하면 만들어진다.

```javascript
let a = new Array(5); // 요소가 없지만 a.length는 5
a = []; // 요소가 없고 length가 0
a[1000] = 0; // 요소 하나를 추가하지만 길이는 1001
```

- delete 연산자를 사용해 성긴 배열을 만들 수 있다.
- 일반적인 배열에 비해 조금 느리지만 메모리를 효율적으로 사용.
- 요소를 검색하는 시간은 일반 적인 객체 프로퍼티 검색과 비슷.
- [1,,3] 처럼 리터럴에 콤바를 반복하면 성긴 배열이 만들어진다.

```javascript
let a1 = [,]; // 요소가 없고 길이는 1
let a2 = [undefined]; // undefined 요소가 하나 존재.
0 in a1; // false 인덱스 0 에 요소가 없음
0 in a2; // true 인덱스 0에 요소 undefined 존재.
```

</br>

## 배열 길이

- 모든 배열에는 length 프로퍼티 존재
- 이 프로퍼티는 일반적인 객체와 배열을 구분하는 특징.
- 일반적인 배열에서 length 프로퍼티는 인덱스에 1을 더한 값
- 성긴 배열의 length 프로퍼티는 포함된 요소 개수보다 크다.
- length 보다 크거나 같은 인덱스는 존재하지 않는다.
- 이를 위해 js 배열에는 특별한 동작 두가지가 있다.
  - 배열의 현재 길이 이상인 i 인덱스에 값을 할당하면 length 프로퍼티를 i + 1 로 갱신
  - length 프로퍼티를 현재 값보다 작은 n 으로 지정하면 n 이상인 배열 요소는 모두 삭제.

```javascript
a = [1, 2, 3, 4, 5];
a.length = 3; // a는 [1,2,3]
a.length = 0; // 요소 전체를 삭제 [] 와 동등
a.length = 5; // 길이는 5 요소는 없음
```

</br>

## 배열 요소 추가와 삭제

- 가장 단순한 방법은 새 인덱스에 값을 할당하는 방법.
- push() 메서드는 배열 마지막에 값을 추가.

```javascript
let a = [];
a.push('zero');
a.push('one', 'two'); // a = 'zero', 'one', 'two'
```

- push()는 a[a.length] 에 값을 할당하는 것과 같다.
- unshift() 를 사용해 배열의 맨 앞에 값을 삽입하고 기존의 요소를 뒤로 미는 것도 가능.
- pop() 메서드는 push()의 반대로 배열의 마지막 요소를 제거하고 그 값을 반환하며 배열의 길이를 1 줄인다.
- shift() 메서드는 배열의 첫 번째 요소를 제거해 반환하며 길이를 1 중리고 나머지 요소를 모두 앞으로 당긴다.

</br>

- delete 연산자로 배열 요소를 삭제 할 수 있다.

```javascript
let a = [1, 2, 3];
delete a[2]; // 1,2
2 in a; // false
a.length; // 3 delete는 길이에 영향을 주지 않는다.
```

- 배열 요소를 삭제하는 것은 그 요소에 undefined를 할당하는 것과 비슷하다. 완전 같지는 않다.
- length프로퍼티가 변하지 않고 빈 공간을 메우기 위해 요소가 이동하지도 않는다.

</br>

- 배열 요소를 삽입, 삭제, 대체하는 범용 메서드 splice() 가 있다.
- length 프로퍼티를 변경하고 필요에 따라 요소를 앞뒤로 움직인다.

</br>

## 배열 순회

- 가장 쉬운 방법은 for/of

```javascript
let letters = [...'hello'];
let string = '';
for (let letter of letters) string += letter;
console.log(string); // hello
```

- 오름차순으로 요소를 반환
- 성긴 배열도 마찬가지로 존재하지 않는 배열 요소에 대해서는 undefined를 반환.
- 각 요소의 인덱스가 필요하다면 entries()메서드와 분해 할당을 이용.

```javascript
let everyother = '';
for (let [index, letter] of letters.entries()) {
  if (index % 2 == 0) everyother += letter;
}
everyother; // hlo
```

</br>

- forEach()도 배열을 순회하는 좋은 방법
- for루프의 변형이 아니라 배열 순회를 함수형으로 바꾼 배열 메서드.
- forEach()는 전달 받은 함수를 각 배열 요소에서 호출.

```javascript
let uppercase = '';
letters.forEach((letter) => {
  uppercase += letter.toUpperCase();
});
uppercase; // HELLO
```

- 배열을 순서대로 순회하며 배열 인덱스를 함수의 두 번째 인자로 전달.
- for/of와 달리 forEach()는 성긴 배열을 인식, 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.

```javascript
let a = [1, 2, 3];
delete a[1];
a.forEach((n) => console.log(n)); // 1 3
let b = [1, 2, 3];
b[1] = undefined;
b.forEach((n) => console.log(n)); // 1 undefined 3 // 삭제는 undefined 할당과 비슷한거지 같지 않다.
```

## 배열 메서드

### 배열 이터레이터 메서드

- 배열 요소를 순서대로 함수에 전달하는 방식으로 동작.
- 배열 요소를 순회, 변환, 필터, 체크, 축소 할 수 있다.
- 모두 첫 번째 인자로 함수를 받으며 각 배열 요소 또는 일부 요소에 대해 그 함수를 한 번씩 호출.
- 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.
- 이 함수는 대부분의 경우 배열 요소의 값, 인덱스, 배열 자체 세가지 인자를 받는다.
- 두 번째 인자를 사용하면 첫 번째 인자인 함수는 자신이 두 번째 인자의 메소드인 것처럼 호출된다.
- 즉, 두 번째 인자가 함수의 this가 된다.
- 이 메서드 중 원래 배열을 수정하는 메서드는 없다.

</br>

- forEach()

  - 첫 번째 인자는 함수, 배열 요소의 값, 인덱스, 배열 자체를 인자로 전달해 이 함수를 호출.
  - ```javascript
    let data = [1, 2, 3, 4, 5],
      sum = 0;
    data.forEach((value) => {
      sum += value;
    });
    ```
  - 모든 요소를함수에 전달하기 전에 반복을 멈출 수 없다. break문등을 쓸 수 없다.

- map()

  - 각 배열 요소를 함수에 전달해 호출, 그 함수가 반환한 값으로 이루어진 배열을 반환.
  - ```javascript
    let a = [1, 2, 3];
    a.map((x) => x * x); //1,4,9
    ```
  - 전달하는 함수는 값을 반환해야 한다.
  - 기존 배열을 수정하지 않는다.
  - 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않지만, 반환된 배열 역시 같은 위치에 갭이 있고 길이 또한 같다.

- filter()

  - 기존 배열의 일부만 포함하는 부분 집합을 반환
  - 전달하는 함수를 기준으로 하며 이 함수는 true, false 를 반환.
  - 반환 값이 true이거나 true로 변환될 수 있는 값이면 해당 요소는 반환되는 배열에 포함.
  - ```javascript
    let a = [5, 4, 3, 2, 1];
    a.filter((x) => x < 3); // [2,1]
    a.filter((x, i) => i % 2 === 0); // [5,3,1]
    ```
  - 성긴 배열에서 존재하지 않는 값은 건너뛰며, 반환되는 배열은 항상 빽빽한 배열이다.
  - 이 특징을 이용해서 성긴 배열에서 갭을 제거 할 수 있다.
  - ```javascript
    let dense = sparse.filter(() => true);
    ```
  - 갭과 함께 undefined, null 요소도 제거 할 수 있다.
  - ```javascript
    a = a.filter((x) => x !== undefined && x !== null);
    ```

- find(), findIndex()

  - 판별 함수에서 true 같은 값을 반환하는 요소를 찾아 배열을 순회한다는 점은 filter()와 같다.
  - filter()와 달리 기준을 만족하는 첫 번째 요소를 만나면 즉시 순회를 멈춘다.
  - 요소를 찾으면 find()는 그 요소를, findIndex()는 그 요소의 인덱스를 반환.
  - 찾지 못하면 find()는 undefined, findIndex()는 -1 을 반환한다.
  - ```javascript
    let a = [1, 2, 3, 4, 5];
    a.findIndex((x) => x === 3);
    a.find((x) => x % 5 === 0);
    a.find((x) => x % 7 === 0);
    ```

- every(), some()

  - 배열 요소에 판별 함수를 적용하고 결과에 따라 true, false 반환.
  - every() 는 판별 함수가 배열의 모든 요소에 대해 true를 반환할 때만 true를 반환.
  - some() 는 배열 요소 중 판별 함수가 true를 반환하는 것이 하나라도 있으면 true를 반환.
  - ```javascript
    let a = [1, 2, 3, 4, 5];
    a.every((x) => x < 10); // true
    a.some(isNaN); // false
    a.some((x) => x % 2 === 0); // true
    ```
  - every(),some() 모두 어떤 값을 반환할지 확실해지는 순간 순회를 멈춘다.

- reduce(), reduceRight()
  - 제공하는 함수를 사용해 배열 요소를 값 하나로 만든다.
  - ```javascript
    let a = [1, 2, 3, 4, 5];
    a.reduce((x, y) => x + y, 0); // 15
    a.reduce((x, y) => x * y, 1); // 120
    a.reduce((x, y) => (x > y ? x : y)); // 5
    ```
  - 인자 두 개를 받는다.
  - 첫 번째 인자는 축소 동작을 행하는 함수.
  - 두 번째 인자는 선택 사항, 함수에 전달할 초깃값. 없다면 배열의 첫 번째 요소를 초깃값으로 사용.
  - 함수는 축소 작업의 결과값, 값, 인덱스, 배열을 인자로 받는다.
  - 처음 함수를 호출하면 이전 축소 작업의 결과값이 없으므로 초깃값을 사용한다.
  - 빈 배열에 초깃값 없이 reduce()를 호출하면 TypeError가 일어난다.
  - reduceRight()는 reduce()와 마찬가지지만 오른쪽에서 왼쪽으로 진행한다는 점이 다르다.
  - 축소 함수에서 this로 사용될 인자는 받지 않는다.
  - 때로는 reduce()에 집착하지 않고 일반적인 루프 구조를 사용해 배열을 처리하는 편이 코드를 읽고 이해하기 쉬울 때도 있다.

### flat(), flatMap()을 이용한 배열 평탄화

- 기존 배열과 같은 요소로 이루어진 평탄한(중첩되지 않은) 새 배열을 반환한다.
- ```javascript
  [1, [2, [3]]].flat(); // [1,2,[3]]
  let a = [1, [2, [3, [4]]]];
  a.flat(4); // [1,2,3,4]
  ```
- 인자없이 flat()을 호출하면 한단계만 평탄화 한다.
- flatMap() 은 map()와 똑같이 동작하지만, 반환하는 배열이 flat()에 전달한 것처럼 자동으로 평탄화 된다.
- 즉, a.flatMap(f) === a.map(f).flat()

### concat()으로 배열 병합

- 기존 배열의 요소를 포함하고 그 뒤에 concat()의 인자를 포함하는 새 배열을 만들어 반환.
- 배열의 배열을 재귀적으로 평탄화하지는 않는다.
- 기존 배열을 수정하지 않는다.
- ```javascript
  let a = [1, 2, 3];
  a.concat(4, 5); // [1,2,3,4,5]
  a.concat([4, 5], [6, 7]); // [1,2,3,4,5,6,7] 평탄화
  a.concat(4, [5, [6, 7]]); // [1,2,3,4,5,[6,7]] // 중텁된 배열은 평탄화 되지 않는다.
  ```

### 스택과 큐 메서드

- push(), pop() 는 배열을 스택처럼 다루는 메서드
- push() 메서드는 배열의 끝에 하나 이상의 새 요소를 추가하고 새 길이를 반환.
- pop()은 그 반대로 마지막 요소를 꺼내서 반환하며 배열의 길이를 줄인다.
- 두 메서드 모두 기존 배열을 수정한다.
- ```javascript
  let stack = [];
  stack.push(1, 2); // [1,2]
  stack.pop(); // [1]
  stack.push([4, 5]); //[1,[4,5]]
  stack.pop(); // [1]
  ```
- push()는 전달한 배열을 평탄화하지 않는다.
- 분해 연산자를 직접 사용해 평탄화 할 수 있다.
- ```javascript
  a.push(...values);
  ```
- unshift()와 shift()메서드는 배열의 앞부분에서 이루어진다.
- unshift()는 시작 부분에 요소를 추가하고, 기존 배열을 뒤로 밀고, 새 길이를 반환.
- shift()는 첫 번째 요소를 반환하고, 기존의 배열을 앞으로 당긴다.
- shift()와 push() 를 써서 큐 데이터 구조를 만들 수 있다.
- ```javascript
  let q = [];
  q.push(1, 2); // [1,2]
  q.shift(); // [2]
  q.push(3); // [2,3]
  q.shift(); // [3]
  ```
- unshift()에 인자 여려 개를 전달하면 모두 한 번에 삽입된다. 하나씩 넣을 때와는 결과가 다르다.
- ```javascript
  let a = [];
  a.unshift(1); // [1]
  a.unshift(2); // [2,1]
  a = [];
  a.unshift(1, 2); // [1,2]
  ```

### 하위 배열

- 일종의 연속적인 영역인 하위 배열을 슬라이스라 한다.

</br>

- slice()

  - 지정된 배열의 하위 배열을 반환.
  - 두 개의 인자는 각각 반환될 슬라이스의 시작과 끝 위치.
  - 첫 번째 인자로 지정된 요소에서 시작, 두 번째 인자로 지정된 요소 바로 앞까지가 포함.
  - 인자를 하나만 사용한다면 반환된 배열은 해당 위치부터 원래 배열의 마지막 요소까지 포함된다.
  - ```javascript
    let a = [1, 2, 3, 4, 5];
    a.slice(0, 3); // [1,2,3]
    a.slice(3); // [4,5]
    a.slice(1, -1); // [2,3,4]
    a.slice(-3, -2); // [3]
    ```
  - 원래 배열을 수정하지 않는다.

- splice()

  - 배열에 요소를 삽입하거나 제거하는 범용 메서드.
  - 원래 배열을 수정한다.
  - 요소를 삭제하거나 삽입할 수 있고 동시에 할 수 있다.
  - 삭제, 삽입이 이루어진 위치 다음에 오는 요소들을 앞이나 뒤로 밀어 빽빽한 배열을 유지한다.
  - 첫 번째 인자는 삽입이나 제거를 시작할 위치.
  - 두 번째 인자는 제거할 요소의 개수, 생략 시 배열 마지막까지.
  - 제거한 것이 없다면 빈 배열을 반환.
  - ```javascript
    let a = [1, 2, 3, 4, 5, 6, 7, 8];
    a.splice(4); // [1,2,3,4]
    a.splice(1, 2); // [1,4]
    a.splice(1, 1); // [1]
    let b = [1, 2, 3, 4, 5];
    b.splice(2, 0, 'a', 'b'); // [1,2,'a','b',3,4,5]
    b.splice(2, 2, [1, 2], 3); // [1,2,[1,2], 3,3,4,5]
    ```
  - 두 번째 이후로 받는 인자는 개수 제한이 없고 첫 번째 인자에서 지정한 위치에서부터 배열에 삽입된다.
  - 배열을 있는 그대로 삽입하고 평탄화 하지 않는다.

- fill()

  - 배열의 요소 또는 슬라이스를 지정된 값으로 바꾼다.
  - 원래 배열을 수정한다.
  - ```javascript
    let a = new Array(5);
    a.fill(0); // [0,0,0,0,0]
    a.fill(9, 1); // [0,9,9,9,9]
    a.fill(8, 2, -1); // [0,9,8,8,9]
    ```
  - 첫 번째 인자는 배열 요소로 사용할 값.

  - 두 번째 인자는 선택 사항으로 시작 인덱스. 생략 시 인덱스 0 부터 시작.

  - 세 번째 인자는 마지막 인덱스로 이 바로 앞까지 진행.

### 배열 검색과 정렬 메서드
- indexOf()와 lastIndexOf()
  - 지정된 값을 배열에서 찾아 그 첫 번째 요소의 인덱스를 반환하며, 찾지 못하면 -1을 반환한다.
  - indexOf()는 배열의 앞에서부터, lastIndexOf()는 배열의 뒤에서부터 검색.
  - ```javascript
    let a = [0,1,2,1,0]
    a.indexOf(1) // 1
    a.lastIndexOf(1) // 3
    a.indexOf(3) // -1
    ```
  - 배열에 기본값이 아니라 객체가 들어 있다면 이들 메서드는 두 찹조가 정확히 같은 객체를 참조하는지 확인.
  - 객체 콘텐츠를 검색하려는 목적이면 find()같은 메서드를 사용.
  - 두 번째 인자는 선택 사항으로 검색을 시작할 배열 인덱스를 나타낸다.

- sort()
  - 배열 요소를 정렬한다. 
  - 인자 없이 sort()를 호출하면 배열 요소를 알파벳순으로 (필요하다면 임시로 문자열로 변환) 정렬.
  - 배열에 정의되지 않은 요소가 있다면 그들은 배열 마지막으로 밀린다.
  - 알파벳이 아닌 다른 순서로 배열을 정렬하고 싶다면 sort()에 비교 함수를 인자로 전달.
  - 첫 번째 인자가 두 번째 인자보다 앞에 있어야 한다면 비교 함수가 0보다 작은 숫자를 반환.
  - 뒤에 있어야 한다면 0 보다 큰 숫자.
  - 두 값이 동등하거나 순서가 상관 없다면 0을 반환.
  - ```javascript
    let a = [33, 4, 1111, 222]
    a.sort() // [1111, 222, 33, 4]
    a.sort(function(a,b) {
      return a-b
    }) // [4,33,222,1111]
    a.sort((a,b) => b-a) // [1111,222,33,4]
    ```
  - ```javascript
    let a = ['ant','Bug','cat','Dog']
    a.sort() // ['Bug', 'Dog', 'ant', 'cat'] 대소문자를 구별
    a.sort(function(s,t) {
      let a = s.toLowerCase()
      let b = t.toLowerCase()
      if(a < b) return -1
      if(a > b) return 1
      return 0
    }) // ['ant','Bug','cat','Dog']
    ```

- reverse()
  - 배열 요소의 순서를 거꾸로 바꾸어 반환.

### 배열을 문자열로 변환
- join()
  - 배열 요소 전체를 문자열로 변환한 다음, 이들을 병합한 결과를 반환.
  - 각 요소를 구분하는 문자열을 선택 사항으로 지정할 수 있다.
  - ```javascript
    let a = [1,2,3]
    a.join() // '1,2,3'
    a.join(' ') // '1 2 3'
    ```
  - 나중에 재사용할 목적으로 배열 콘텐츠를 텍스트 형태로 바꾸는 것이라면 JSON.stringify()를 사용.

### 배열 비슷한 객체
- 다른 객체에는 없는 배열의 특별한 기능
  - 배열에 새 요소를 추가할 때마다 length 프로퍼티가 자동으로 업데이트
  - length를 더 작은 값으로 변경하면 배열 요소를 그에 맞게 버린다.
  - 배열은 Array.prototype에서 유용한 메소드를 상속한다.
  - Array.isArray()는 배열을 받으면 true를 반환.

- 이것들은 객체와 배열을 구분하는 특징. 배열을 정의하는 핵심 특징이 아님.
- 숫자인 length 프로퍼티가 있고 음이 아닌 정수 프로퍼티가 있는 객체라면 모두 일종의 배열로 간주.
- 배열 비슷한 객체는 배열에서 했던 것과 같은 코드를 써서 이들을 순회할 수 있다.
- 클라이언트 사이드 js 에는 document.querySelectorAll() 처럼 HTML 문서에서 배열 비슷한 객체를 반환하는 메서드가 많다.
- 배열 메서드는 대부분 배열 비슷한 객체에서도 동작.
- 배열 비슷한 객체는 Array.prototype을 상속하지 않으므로 배열메서드를 직접적으로 호출할 수 없음.
- 하지만 Function.call 메서드를 통해 간접적으로 호출 가능.
- ```javascript
  let a = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    'length': 3
  }
  Array.prototype.join.call(a,'+') // 'a+b+c'
  Array.prototype.map.call(a, x => x.toUpperCase()) // ['A','B','C']
  let b = Array.from(a) // ['a','b','c'] 배열 복사 배열비슷한객체를 진정한 배열로 변환, 할당.
  ```

  

  